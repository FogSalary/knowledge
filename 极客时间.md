# Git 入门三剑客


### 探秘 Git 原理
```
git init  # 初始化一个仓库
cd .git  # 进入 .git 文件夹
ls -al  # 列举文件夹下的所有内容
cat HEAD  # 返回一个引用，指示现在指向的分支
git branch -av
git checkout master
cat HEAD
# 切换分支时，会导致 HEAD 中内容发生变化
# HEAD 内容表面我们当前工作在哪个分支上

cat config  # 输出 config 中的内容
# git config local 相应的信息记录在 config 中
vi config  # 直接修改文件中的 user name 并保存
git config --local --list
git config --local user.name
# 再将 user name 变更回去
git config --local user.name "xxx"
cat config  # 检查内容是否修改

cd refs  # 进入 refs 文件夹
# 里面包含 heads 和 tags
# tags 对应标签，里程碑， heads 对应分支
cd heads
ls -al  # 从中可以看出当前本地仓库具有的分支
cat master
# 此时输出 sha id，存放的对象
git cat-file -t shaid  # 查看存储对象的类型
git branch -av
可以看到，其中存放的是指向 master 最新 commit 的指针
cat tmp

cd tags
ls -al
cat tags_name  # 返回标签对应的 commit id 
git cat-file -t shaid
git cat-file -p shaid
git cat-file -t object_id

cd objects/
ls -al  # 其中包括很多两个字符的文件夹、info 和 pack
cd xx
ls -al
git cat-file -t xx+ls 内容 行成 shaid
# 这里会返回 tree
# 截止为止，已经有了两种类型
# commit 、 tree
git cat-file -p shaid
# 看类型就用 -t 看内容用 -p 
# 此时引入新的类型 blob ，对应文件，文件对象
```


### commit、tree 和 blob 三个对象之间的关系
对象类型
存储是 Git 的一个核心技术点

Git 对象彼此关系
Git 具有如下三种对象类型：
- commit
- tree
- blob
![alt text](./images/geek_image.png)

一个 commit 对应一棵树， 快照（所有文件夹以及文件的快照）


## 练习：数一数 tree 的个数

![alt text](./images/geek_image-1.png)
``` bash
git init watch_git_objects
cd watch_git_objects/
ls -al
mkdir doc
git status
cd doc
echo "Hello World!" > readme
cd ..
git status
find .git/objects -type f
git add doc
git status
find .git/objects -type f
git cat-file -t xxxxid
git cat-file -p xxxxid
clear
git status
git commit -m "Add readme"
find .git/objects -type f
git cat-file -t xxxxid
git cat-file -p xxxxid
git cat-file -t xxxxid
git cat-file -p xxxxid
git cat-file -t xxxxid
git cat-file -p xxxxid
git cat-file -t xxxxid
git cat-file -p xxxxid

```

## 分离头指针情况下的注意事项
分离头指针意味着当前不属于任何一个分支，这将导致切换到其他分支后，这部分的工作将会丢失

by the way，对于做一些尝试性变更的时候，可以考虑使用分离头指针
``` bash
git branch -av
git log
git checkout commitid
ls -al
vi xxx/xxx.xx
git status
git commit -am "xxxxxxxx"
git log
# 此时可以看到输出结果中，只有 HEAD，没有任何一个分支名，表明当前处于分离头指针状态
git branch -av
git checkout master
gitk --all
git branch branch_name detached_head_id
gitk --all
```
特别注意，如果当前的工作是必要的，切记要与某个分支绑定在一起；


## 进一步理解 HEAD 和 branch

``` bash
git branch -av
git log
git checkout -b fix_readme master/commitid  # 创建并切换到新建分支
git log -n1
gitk --all
cat .git/HEAD
cat .git/refs/heads/xxxx
git cat-file -t xxxxxid
git cat-file -p xxxxxid
git log
git diff commitid1 commitid2
git diff HEAD HEAD~1/HEAD^

```


## 怎么删除不需要的分支

``` bash
pwd
git branch -av
gitk --all
git branch -d xxxxx
git branch -D xxxxx
gitk --all

```

## 怎么修改最新 commit 的 message？
修改最近一次提交的 commit 的 message

``` bash
pwd
git branch -av
git log -1
git commit  --amend

```

## 怎么修改老旧 commit 的 message
变基

``` bash
pwd
git branch -av
git log -3
git rebase -i commitid_parent
git branch -av
git log -n3 --graph


```

![alt text](./images/geek_image-2.png)

值得注意的是，上述变的操作最好是在本地尚未提交的快照中进行，如果已经推送到远程仓库，则不要进行变基操作，否则会对其他协同开发的人员造成不良影响；



## 怎样把连续的多个 commit 整理成一个
场景：整理过去提交的多个 commit

``` bash
pwd
git branch -av
git log
git rebase -i commitid_parent
git log --graph
```

![alt text](./images/geek_image-3.png)


## 怎么把间隔的几个 commit 整理成一个

``` bash
git rebase -i commitid 如果该 commit 没有 parent，则使用自身即可
# 在交互界面中，需要将自身 commit 也加入进去
# 在交互界面中，调整 commit 的顺序，使得间隔的 commit 变为连续的 commit
git status
git rebase --continue
git log
gitk --all
```


## 怎么比较暂存区和 HEAD 所含文件的差异
